/*
 * DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
 */
/*

 * Copyright (c) 2003 - 2021 Codecraft, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/*
 *++
 * Project:
 *   +elevator+ -- a test program for coroutines and ncurses.  <by Cary WR Campbell>
 *
 * Module:
 *   +elevator+ executable for macOS.
 *--
 */
/*
 * Configuration
 */
/******************************* Configuration ********************************/
/* Uncomment the following define line for a histogram of coroutine           **
** round-trip latencies.                                                      */
#define SHOW_HISTOGRAM
/* Uncomment the following define line for more info about the configuration  **
** sent from the test program.                                                */
//#define VERBOSE_CONFIGURATION
/* Uncomment the following define line to show elevator car availability.     */
//#define SHOW_AVAILABILITY
/******************************************************************************/
/*
 * Include files
 */
#include <iostream>
//#include <stdio.h>
#include "pipe_interface.h"
#include "pipe_commands.cpp"
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include "sccorlib.h"
#include <curses.h>
#include "histospt.h" 
#include "fifo.h"
using namespace std ;
/*
 * Type Definitions
 */
typedef enum direction { up, down, none } direction ;
typedef enum openness { doorHalfOpen, doorOpen, doorOpenWaiting, doorHalfClosed,
                        doorClosed, doorLocked } openness ;
/*
 * Constants
 */
const char APP_VERSION[] = "1.0" ;
const int MAX_NUMBER_OF_FLOORS = 9 ;
const int MAX_ALERT_MESSAGE_SIZE = 128 ;
const int DEFAULT_DOOR_REMAINS_OPEN_TIME = 5000 ;                     // <1>
const int DEFAULT_DOOR_TRANSIT_TIME = 1000 ;                          // <1>
const int MAX_DOOR_HEIGHT = 7 ;                                       // <2>
const int DEFAULT_POSITION_TRANSITION_TIME = 2000 / MAX_DOOR_HEIGHT ; // <3>
const int MIN_NUMBER_OF_FLOORS = 2 ;
const int SAFE_SIZE = 32 ;
const int waitBeforeClosingPipes = 2000 ; // ms
const int pipeCheckInterval = 1 ;
const int MAX_FLOOR_LABEL_WIDTH = 4 ; 
const int MAX_DOOR_WIDTH = 11 ; 
const int NORMAL_EXECUTION_EXIT = 0 ;
const int MAX_NUMBER_OF_ELEVATORS = 9 ;
const int DELAY_BEFORE_ERASING_COMMAND = 1000 ; // ms
const int USER_REQUESTED_EXIT = 99 ;
const int dummy = 0 ; // unused parameter
const int MIN_NUMBER_OF_ELEVATORS = 1 ;
const int CAR_HEIGHT = 5 ; 
/*
 * Variables
 */
char ourNameAndVersion[ MAX_NAME_AND_VERSION_LEN ] ;
bool useNamedPipes ;
int numberOfElevators ;
int numberOfFloors ;
char alertMessage[ MAX_ALERT_MESSAGE_SIZE ] ;
int doorRemainsOpenTime ;
int doorTransitTime ;
int positionTransitionTime ;
int commandPipeFd ;
int statusPipeFd ; 
char floorLabels[ MAX_NUMBER_OF_FLOORS + 1 ] ;
int groundFloor ;
WINDOW *w ;
int nrows ;
int ncols ;
int blockClearTime ;
int doorOpenCloseTime ;
double floorHeight ;
double maxCabinVelocity ;
int maxCloseAttempts ;
double minStoppingDistance ;
int normalDoorWaitTime ;
int exitCode ;
volatile bool orderlyStop ;
char roundtripCounterOutputString[ 80 ] ; // ample
#ifdef SHOW_HISTOGRAM
TimeIntervalHistogram itHistCR( "Coresume roundtrip times (us)",
                                0L, 250, 40 ) ;            // <1>
#endif // def SHOW_HISTOGRAM
Fifo notification_Q ;
int groundFloorRow ; 
unsigned int timeMultiplier = 1 ; 
bool xgetchCharAvailable ;
int xgetchChar ;
/*
 * Forward References
 */
char *strupr( char *string ) ;
bool checkInput( int numberOfElevators, const char *floorSpecification,
                 int &numberOfFloors, int &grndFloor, char *floorLabels ) ;
int kbhit( void ) ;
void roundtripCounter( void ) ;
void elevatorSimulation( int numberOfElevators, int numberOfFloors,
                         char floorLabels[] ) ;
void initDoor( int y, int x ) ;
void car( int shaft ) ;
void pipeHandler( void ) ;
void pushFloorButton( bool isOn, direction theDirection,
                      int udButtonColumn, int floorLabelRow ) ;
void drawCar( int shaftNumber, int positionAbove, char theFloor,
              char floorLabels[], int floorLabelRows[], int buttonsPressed,
              direction theDirection, int groundFloorRow
              #ifdef SHOW_AVAILABILITY
              , bool available
              #endif // def SHOW_AVAILABILITY
            ) ;
void drawOpenDoor( int y, int x, openness state ) ;
void drawUpDownIndicator( int y, int x, direction indicatorDir ) ;
bool xkbhit( void ) ;
int  xgetch( void ) ;          // simulated from pipe input
void pushCarButton( bool isOn, int shaft, char theCarButton,
                    int positionAbove, int floorLabelRow ) ;
/*
 * elevator main Routine
 */
int main ( int argc, char *argv[] ) {
for ( int i = 1; i < argc; i++ ) {
   if ( !strcmp( strupr( argv[ i ] ), "?" )
             || !strcmp( argv[ i ], "-?" )
             || !strcmp( argv[ i ], "-H" )
             || !strcmp( argv[ i ], "-HELP" )
             || !strcmp( argv[ i ], "HELP" ) ) {
      cout << "\r\nelevator is a simulation of 1 to 9 elevator shafts in\r\n"
              "in a building with from 2 to 9 floors.\r\n\r\n" ;
      cout << "Syntax:" << "\r\n\r\n" ;
      cout << "  elevator -floors [<count>|<labels>] -n <elevators> "
              "[-pipes] [-wait]\r\n\r\n" ;
      cout << "The -pipes option causes the simulation to communicate via "
              "\r\nnamed pipes (vs. using normal console input).\r\n\r\n" ;
      cout << "The -wait option causes the simulation to pause prior to "
              "\r\nthe simulation to display some execution details.\r\n\r\n" ;
      cout << "For example:\r\n\r\n" ;
      cout << "  elevator -floors B#L2-4 -n 3 -pipes\r\n\r\n" ;
      cout << "creates a simulation of 3 elevator shafts in a building\r\n" ;
      cout << "having five floors, labeled 'B', 'L', '2', '3', and '4'.\r\n" ;
      cout << "In this example, the floor labeled 'L' is the ground floor."
           << "\r\n" ;
      cout << "Named pipes are to be used for communications with a testing "
              "process.\r\n\r\n" ;
      cout << "Commands available during the simulation:\r\n\r\n" ;
      cout << "  c<floor><car>      pushes <floor> button in <car>.\r\n" ;
      cout << "  f<floor><up|down>  pushes <floor> call up or down button."
              "\r\n" ;
      cout << "  q                  ends the simulation.\r\n" ;
      cout << "  xnn<enter>         speeds up the simulation by a factor of "
              "nn (1 - 10).\r\n\r\n" ;
      cout << "Examples:\r\n";
      cout << "  cb4                sends car 4 to the basement ('b').\r\n" ;
      cout << "  f3u                pushes the up button on floor 3."
              "\r\n\r\n" ;

      exit( 411 ) ;
   }
}
int maxNameLen = MAX_NAME_AND_VERSION_LEN - strlen( APP_VERSION ) - 2 ;
bool waitingForFloors = false ;
bool waitingForNumberOfElevators = false ;
bool waiting = false ;
char floorSpecification[ MAX_NUMBER_OF_FLOORS + 1 + 1 ] ;  // <1>
floorSpecification[ 0 ] = '\0';
if ( maxNameLen > 0 ) {
   if ( strlen( argv[ 0 ] ) > maxNameLen ) {
      argv[ 0 ][ maxNameLen ] = '\0' ;
   }
   sprintf( ourNameAndVersion, "%s %s", argv[ 0 ], APP_VERSION ) ;
} else {
   char str[ 80 ] ; // ample
   sprintf( str, "Error: APP_VERSION string is too long: '%s'.", APP_VERSION ) ;
   cout << str << "\r\n" ;
   exit( 911 ) ;
}
alertMessage[ 0 ] = '\0' ;                                 // <1>
useNamedPipes = false ;
doorRemainsOpenTime = DEFAULT_DOOR_REMAINS_OPEN_TIME ;
doorTransitTime = DEFAULT_DOOR_TRANSIT_TIME ;
numberOfElevators = 0 ;
numberOfFloors = 0 ;
positionTransitionTime = DEFAULT_POSITION_TRANSITION_TIME ;
for ( int i = 1; i < argc; i++ ) {
   if ( !strncmp( strupr( argv[ i ] ), "-F", 2 ) ) {
      waitingForFloors = true ;
   } else if ( !strncmp( strupr( argv[ i ] ), "-N", 2 ) ) {
      waitingForNumberOfElevators = true;
   } else if ( !strncmp( strupr( argv[ i ] ), "-P", 2 ) ) {
      useNamedPipes = true ;
   } else if ( !strncmp( strupr( argv[ i ] ), "-W", 2 ) ) {
      waiting = true ;
   } else if ( waitingForFloors ) {
      if ( strlen( argv[ i ] ) >= MAX_NUMBER_OF_FLOORS + 2 ) {
         char str[ 80 ] ; // ample
         sprintf( str, "Error: Too many floor labels: '%s'.", argv[ i ] ) ;
         cout << str << "\r\n" ;
         exit( 911 ) ;
      }
      if ( strlen( argv[ i ] ) == 1 ) {
         if ( isdigit( argv[ i ][ 0 ] ) ) {
            numberOfFloors = atoi( argv[ i ] ) ;
         } else {
            char str[ 80 ] ; // ample
            sprintf( str, "Error: Invalid floor label: '%s'.", argv[ i ] ) ;
            cout << str << "\r\n" ;
            exit( 911 ) ;
         }
      } else {
         strcpy( floorSpecification, argv[ i ] ) ;
      }
      waitingForFloors = false ;
   } else if ( waitingForNumberOfElevators ) {
      numberOfElevators = atoi( argv[ i ] ) ;
      waitingForNumberOfElevators = false ;
   } else {
      char str[ 80 ] ; // ample
      sprintf( str, "Error: Unrecognized parameter specified: '%s'.",
                    argv[ i ] ) ;
      cout << str << "\r\n" ;
      exit( 911 ) ;
   }
}
if ( useNamedPipes ) {
int retVal = mkfifo( ElevatorStatusPipe, 0666 ) ;
if ( retVal == -1 && errno != EEXIST ) {
   perror( "Error creating the ElevatorStatusPipe" ) ;
   exit( 1 ) ;
}
retVal = mkfifo( ElevatorCommandsPipe, 0666 ) ;
if ( retVal == -1 && errno != EEXIST ) {
   perror( "Error creating the ElevatorCommandPipe" ) ;
   exit( 1 ) ;
}
commandPipeFd = open( ElevatorCommandsPipe, O_RDONLY | O_NONBLOCK ) ;
if ( commandPipeFd == -1 ) {
   perror( "Unable to open the ElevatorCommandPipe" ) ;
   exit( 1 ) ;
}

cout << "Waiting for test program to start." << endl ;

statusPipeFd  = open( ElevatorStatusPipe, O_WRONLY ) ;
if ( statusPipeFd == -1 ) {
   perror( "Unable to open the ElevatorStatusPipe" ) ;
   exit( 1 ) ;
}
if ( strlen( floorSpecification ) != 0 || numberOfFloors != 0
  || numberOfElevators != 0 ) {
   if ( numberOfElevators == 0 ) {
      numberOfFloors = 0 ;             
      floorSpecification[ 0 ] = '\0' ;
   } else if ( numberOfFloors == 0 && strlen( floorSpecification ) == 0 ) {
      numberOfElevators = 0 ;
   } else {
      if ( strlen( floorSpecification ) == 0
        && numberOfFloors >= MIN_NUMBER_OF_FLOORS
        && numberOfFloors <= MAX_NUMBER_OF_FLOORS ) {
         for ( int i = 0; i < MAX_NUMBER_OF_FLOORS + 2; i++ ) {
            if ( i < numberOfFloors ) {
               floorSpecification[ i ] = '0' + i + 1 ;
            } else {
               floorSpecification[ i ] = '\0' ;
            }
         }
      }
      #ifdef VERBOSE_CONFIGURATION 
      {
         char str[ 200 ] ; // ample
         sprintf( str, "Before checkInput> numberOfElevators: %i, "
                  "floorSpecification: %s, numberOfFloors: %i, "
                  "groundFloor: %i, floorLabels: %s",
                  numberOfElevators, floorSpecification, numberOfFloors,
                  groundFloor, floorLabels ) ;
         cout << str << endl ;
      }
      #endif // def VERBOSE_CONFIGURATION
      bool inputIsOK = checkInput( numberOfElevators, floorSpecification,
                                   numberOfFloors, groundFloor,
                                   floorLabels ) ;
      #ifdef VERBOSE_CONFIGURATION
      {
         char str[ 200 ] ; // ample
         sprintf( str, "After checkInput> numberOfElevators: %i, "
                  "floorSpecification: %s, numberOfFloors: %i, "
                  "groundFloor: %i, floorLabels: %s",
                  numberOfElevators, floorSpecification, numberOfFloors,
                  groundFloor, floorLabels ) ;
         cout << str << endl ;
      }
      #endif // def VERBOSE_CONFIGURATION
      if ( !inputIsOK ) {
         char str[ SAFE_SIZE ];
         sprintf( str, "%s\n", P_END ) ;
         write( statusPipeFd, str, strlen( str ) ) ;
         sleepMs( waitBeforeClosingPipes ) ;
         exit( 911 ) ;
      }
   }
}
bool configuring = true ;
char buf[ MAX_BUF_SIZE ] ;
int  numRead ;
while ( configuring ) {
   numRead = read( commandPipeFd, buf, MAX_BUF_SIZE ) ;
   if ( numRead == -1 ) {
      if ( errno == EAGAIN ) {
         sleepMs( pipeCheckInterval ) ;
      } else {
         // An error has occurred reading the pipe.
         perror( "Error reading the ElevatorStatusPipe" ) ; // <1>
         exit( 3 ) ;
      }
   } else if ( numRead > 0 ) {
      buf[ numRead ] = '\0' ; // for safety
      #ifdef VERBOSE_CONFIGURATION
      {
         char str[ 80 ] ; // ample
         sprintf( str, "Received via pipe (%i chars)> buf: '%s'",
                  numRead, buf ) ;
         cout << str << endl ;
      }
      #endif // def VERBOSE_CONFIGURATION
      if ( !strcmp( buf, helloMessage ) ) {
         char str[ SAFE_SIZE ] ;
         sprintf( str, "%s%s\n", P_OK, ourNameAndVersion ) ;
         write( statusPipeFd, str, strlen( str ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( P_OK ), P_OK ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strcmp( buf, endConfiguration ) ) {
         configuring = false ;
      }
      else if ( !strcmp( buf, queryMaxDimensions ) ) {
         int  maxNoOfFloors ;
         int  maxNoOfElevators ;
         char isFixed ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         if ( numberOfFloors != 0 && numberOfElevators != 0 ) {
            isFixed          = groundFloor + '0' ;
            maxNoOfFloors    = numberOfFloors + '0' ;
            maxNoOfElevators = numberOfElevators + '0' ;
         } else {
            w = initscr() ;
            getmaxyx( w, nrows, ncols ) ;
            endwin() ;
            isFixed = '*' ;
            maxNoOfFloors    = ( nrows - 2 ) / MAX_DOOR_HEIGHT + '0' ;
            maxNoOfElevators = ( ncols - MAX_FLOOR_LABEL_WIDTH - 2 )
                                                   / MAX_DOOR_WIDTH + '0' ;
         }
         sprintf( buf, "%s%c%c%c\n", commandSignature,
                  maxNoOfFloors, maxNoOfElevators, isFixed ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strcmp( buf, queryFloorLabels ) ) {
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s%s\n", commandSignature, floorLabels ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setBlockClearTime,
                          strlen( setBlockClearTime ) ) ) {
         blockClearTime = atoi( buf + strlen( setBlockClearTime ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setDoorOpenCloseTime,
                          strlen( setDoorOpenCloseTime ) ) ) {
         doorOpenCloseTime = atoi( buf + strlen( setDoorOpenCloseTime ) ) ;
         doorTransitTime   = doorOpenCloseTime / 2 ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setFloorHeight,
                          strlen( setFloorHeight ) ) ) {
         floorHeight = atof( buf + strlen( setFloorHeight ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
            sprintf( str, "floorHeight (received): '%f'", floorHeight ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setFloorLabels, strlen( setFloorLabels ) ) ) {
         strcpy( floorLabels, buf + strlen( setFloorLabels ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setGroundFloorLevel,
                          strlen( setGroundFloorLevel ) ) ) {
         groundFloor = atoi( buf + strlen( setGroundFloorLevel ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setMaxCabinVelocity,
                          strlen( setMaxCabinVelocity ) ) ) {
         maxCabinVelocity = atof( buf + strlen( setMaxCabinVelocity ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf ( str, "Written via pipe (%li chars)> buf: '%s'",
                      strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setMaxCloseAttempts,
                          strlen( setMaxCloseAttempts ) ) ) {
         maxCloseAttempts = atoi( buf + strlen( setMaxCloseAttempts ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setMinStoppingDistance,
                          strlen( setMinStoppingDistance ) ) ) {
         minStoppingDistance = atof( buf + strlen( setMinStoppingDistance ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setNormalDoorWaitTime,
                          strlen( setNormalDoorWaitTime ) ) ) {
         normalDoorWaitTime = atoi( buf + strlen( setNormalDoorWaitTime ) ) ;
         doorRemainsOpenTime = normalDoorWaitTime ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setNumberOfElevators,
                          strlen( setNumberOfElevators ) ) ) {
         numberOfElevators = atoi( buf + strlen( setNumberOfElevators ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
      else if ( !strncmp( buf, setNumberOfFloors,
                          strlen( setNumberOfFloors ) ) ) {
         numberOfFloors = atoi( buf + strlen( setNumberOfFloors ) ) ;
         char commandSignature[ 3 ] ; // ample for "cc"
         strncpy( commandSignature, buf + 1, 2 ) ;
         commandSignature[ 2 ] = '\0' ;
         sprintf( buf, "%s#%s\n", commandSignature, P_OK ) ;
         write( statusPipeFd, buf, strlen( buf ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
                     strlen( buf ), buf ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      } 
      else {
         char str [SAFE_SIZE ] ;
         sprintf( str, "%s\n", P_BAD ) ;
         write( statusPipeFd, str, strlen( str ) ) ;
         #ifdef VERBOSE_CONFIGURATION
         {
            char str[ 80 ] ; // ample
            sprintf( str, "Written via pipe (%li chars)> buf: '%s'", strlen( P_BAD ), P_BAD ) ;
            cout << str << endl ;
         }
         #endif // def VERBOSE_CONFIGURATION
      }
   }
}
positionTransitionTime = 1000 * floorHeight / ( MAX_DOOR_HEIGHT * maxCabinVelocity ) ;
bool configurationIsOK = true ;
char *configResult = ( char * )P_OK ;
if ( !strlen( floorLabels ) ) {
   configurationIsOK = false ;
   configResult = ( char * )P_BAD ;
} else {
   if ( !strlen( floorSpecification ) ) {
      char *pFs = floorSpecification ;
      for ( int i = 0; i < numberOfFloors; i++ ) {
         if ( i == groundFloor ) {
            *pFs++ = '#' ;
         } else {
            *pFs++ = floorLabels[ i ] ;
         }
      }
      *pFs++ = '\0';
   }
   #ifdef VERBOSE_CONFIGURATION
   {
      char str[ 80 ] ; // ample
      sprintf( str, "floorLabels: '%s', floorSpecification: '%s'",
               floorLabels, floorSpecification ) ;
      cout << str << endl ;
   }
   #endif // def VERBOSE_CONFIGURATION
   configurationIsOK = checkInput( numberOfElevators, floorSpecification,
                                   numberOfFloors, groundFloor,
                                   floorLabels ) ;

   if ( !configurationIsOK ) {
      configResult = ( char * )P_BAD ;
   }
}
char commandSignature[ 3 ] ; // ample for "cc"
strncpy( commandSignature, endConfiguration + 1, 2 ) ;
commandSignature[ 2 ] = '\0' ;
sprintf( buf, "%s#%s\n", commandSignature, configResult ) ;
write( statusPipeFd, buf, strlen( buf ) ) ;
#ifdef VERBOSE_CONFIGURATION
{
char str[ 80 ] ; // ample
sprintf( str, "Written via pipe (%li chars)> buf: '%s'",
         strlen( buf ), buf ) ;
cout << str << endl ;
}
#endif // def VERBOSE_CONFIGURATION
if ( !configurationIsOK ) {
   exit( 911 ) ;
}
} else {
if ( argc < 5 ) {
   cout << "Error: elevator requires two parameters, '-floors' and '-n'."
        << "\r\n"
        << "See help option (-?) for details." << "\r\n" ;
   exit( 911 ) ;
}
if ( strlen( floorSpecification ) == 0
  && numberOfFloors >= MIN_NUMBER_OF_FLOORS
  && numberOfFloors <= MAX_NUMBER_OF_FLOORS ) {
   for ( int i = 0; i < MAX_NUMBER_OF_FLOORS + 2; i++ ) {
      if ( i < numberOfFloors ) {
         floorSpecification[ i ] = '0' + i + 1 ;
      } else {
         floorSpecification[ i ] = '\0' ; // nul characters
      }
   }
}
bool inputIsOK = checkInput( numberOfElevators, floorSpecification,
                             numberOfFloors, groundFloor, floorLabels ) ;
if ( !inputIsOK ) {
   exit( 911 ) ;
}
}
exitCode = NORMAL_EXECUTION_EXIT ;
orderlyStop = false ;
srandom( 1 ) ;
w = initscr() ;
start_color() ; noecho() ; nonl() ;
use_default_colors() ;
init_pair( 1, (short)(COLOR_BLUE    | A_BOLD), -1 ) ;
init_pair( 2, (short)(COLOR_RED     | A_BOLD), -1 ) ;
init_pair( 3, (short)(COLOR_GREEN   | A_BOLD), -1 ) ;
init_pair( 4, (short)(COLOR_YELLOW  | A_BOLD), -1 ) ;
init_pair( 5, (short)(COLOR_BLACK           ), COLOR_CYAN ) ;
init_pair( 6, (short)(COLOR_BLACK           ), COLOR_WHITE ) ;
init_pair( 7, (short)(COLOR_BLACK           ), (short)(COLOR_YELLOW  | A_BOLD) ) ;
#define COLOR_COUNT 7
cbreak() ;
getmaxyx( w, nrows, ncols ) ;
int old_visibility ;
old_visibility = curs_set( 0 ) ;
clear() ;
refresh() ;
cobegin( 2,                                    // <1>
         roundtripCounter,   0,                // <2>
         elevatorSimulation, 3,                // <3>
                             numberOfElevators,
                             numberOfFloors,
                             floorLabels
) ;
curs_set( old_visibility ) ;
refresh() ;
nocbreak() ; echo() ;
endwin() ;
if ( strlen( alertMessage ) > 0 ) {
   cout << "\r\n  *** ALERT: " << alertMessage << "\r" << endl ;
}
cout << "\r\n" << roundtripCounterOutputString << "\r" << endl ;
#ifdef SHOW_HISTOGRAM
itHistCR.show( false ) ;                                   // <1>
itHistCR.reset() ;                                         // <2>
#endif // def SHOW_HISTOGRAM

return( exitCode ) ;
}
/*
 * elevator Coroutines
 */
void elevatorSimulation( int numberOfElevators, int numberOfFloors,
                         char floorLabels[] ) {
   bool shouldPause = false ;
   int curRow = 2 ;
   if ( numberOfFloors * MAX_DOOR_HEIGHT + 2 > nrows ) {
      char str[ 90 ]; // ample
      sprintf( str, "Error: %i floors (%s) require a window height "
               "of at least %i rows.", numberOfFloors, floorLabels,
              numberOfFloors * MAX_DOOR_HEIGHT + 2 ) ;
      mvwaddstr( w, curRow++, 3, str ) ;
      sprintf( str, "The simulation is currently running in a window with "
               "a height of %i rows.", nrows ) ;
      mvwaddstr( w, curRow++, 3, str ) ;
      wrefresh( w ) ;
      curRow++ ; // blank line between messages
      orderlyStop = true ;
      shouldPause = true ;
   }
   if ( numberOfElevators * MAX_DOOR_WIDTH + MAX_FLOOR_LABEL_WIDTH + 2 > ncols ) {
      char str[ 90 ] ; // ample
      sprintf( str, "Error: %i elevators require a window width of at least "
               "%i columns.", numberOfElevators,
               numberOfElevators * MAX_DOOR_WIDTH + MAX_FLOOR_LABEL_WIDTH + 2 ) ;
      mvwaddstr( w, curRow++, 3, str ) ;
      sprintf( str, "The simulation is currently running in a window with "
                    "a width of %i columns.", ncols ) ;
      mvwaddstr( w, curRow++, 3, str ) ;
      wrefresh( w ) ;
      orderlyStop = true ; 
      shouldPause = true ;
   }
   int udButtonColumn ;
   int availableCars = 0 ; 
   int servicingFloorCars = 0 ;
   static int carButtons[ MAX_NUMBER_OF_ELEVATORS + 1 ] ;       
   static int carPositionAbove[ MAX_NUMBER_OF_ELEVATORS + 1 ] ; 
   static char carPositionLabel[ MAX_NUMBER_OF_ELEVATORS + 1 ] ; 
   const int commandPosition = MAX_FLOOR_LABEL_WIDTH + 12 ; 
   int commandOffset = 0 ;
   unsigned int commandEraseTimeMs = 0 ;
   Notification theNotification ;
   Component    sender ;
   Component    destination ;
   char         data0 ;
   char         data1 ;
   char         data2 ;
   char         data3 ;
   openness     doorPosition[ MAX_NUMBER_OF_ELEVATORS + 1 ] ;     // 1-indexed
   int          floorCallDown[ MAX_NUMBER_OF_ELEVATORS + 1 ] ;    // 1-indexed
   int          floorCallUp[ MAX_NUMBER_OF_ELEVATORS + 1 ] ;      // 1-indexed
   int          floorsCalledUp     = 0 ;
   int          floorsCalledDown   = 0 ;
   unsigned int partialTimeMultiplier ;
   unsigned int previousTimeMultiplier ;
   direction    theDirection ;
   char         theFloor ;
   bool         waitingForButtonLabel = false ;
   bool         waitingForCarNumber   = false ;
   bool         waitingForEnter       = false ;
   bool         waitingForFirstDigit  = false ;
   bool         waitingForSecondDigit = false ;
   bool         waitingForDirection   = false ;
   bool         waitingForFloorLabel  = false ;
   bool         waitingToClearCommand = true ;
   struct timeval tv ;
   static int floorLabelRows[ MAX_NUMBER_OF_FLOORS ] ; 
   int currentLabelRow = nrows - 5 ; 
   for ( int i = 0; i < numberOfFloors; i++ ) {
      floorLabelRows[ i ] = currentLabelRow ;
      currentLabelRow -= MAX_DOOR_HEIGHT ;
   }
   if ( !orderlyStop ) {
      char str[ 80 ] ; // ample
      for ( int i = 0; i < numberOfFloors; i++ ) {
         sprintf( str, "[%c]", floorLabels[ i ] ) ;
         mvwaddstr( w, floorLabelRows[ i ], 0, str ) ;
      }
   for ( int i = 0; i < numberOfElevators; i++ ) {
      sprintf( str, "[%c]", '0' + i + 1 );
      mvwaddstr( w, max( 0, floorLabelRows[ numberOfFloors - 1 ] - 5 ),
                 MAX_FLOOR_LABEL_WIDTH + MAX_DOOR_WIDTH * i + 5, str ) ;
   }
   for ( int i = 0; i < numberOfElevators; i++ ) {
      for ( int j = 0; j < numberOfFloors; j++ ) {
         initDoor( floorLabelRows[ j ] - 2,
                   MAX_FLOOR_LABEL_WIDTH + MAX_DOOR_WIDTH * i + 3 ) ;
      }
   }
   groundFloorRow = floorLabelRows[ groundFloor ] + 3 ;
   mvwhline( w, groundFloorRow, 0, '=',
             MAX_FLOOR_LABEL_WIDTH + MAX_DOOR_WIDTH * numberOfElevators ) ;
   udButtonColumn = numberOfElevators * MAX_DOOR_WIDTH
                  + MAX_FLOOR_LABEL_WIDTH + 1 ; // on the far right
   for ( int i = 0; i < numberOfFloors; i++ ) {
      if ( i != numberOfFloors - 1 ) {
         mvwaddch( w, floorLabelRows[ i ] - 1, udButtonColumn,
                   'U' | COLOR_PAIR( 6 ) ) ;  // black on light grey
      }
      if ( i != 0 ) {
         mvwaddch( w, floorLabelRows[ i ], udButtonColumn,
                   'D'  | COLOR_PAIR( 6 ) ) ; // black on light grey
      }
   }
   mvwaddstr( w, nrows - 1, MAX_FLOOR_LABEL_WIDTH + 3, "Command: " ) ;
   wrefresh( w ) ;
   }
   if ( !orderlyStop ) {
      for ( int i = 1; i <= numberOfElevators; i++ ) {
         invoke( (COROUTINE)car, 1, i ) ;
         coresume() ; 
      carButtons[ i ] = 0 ; 
      floorCallUp[ i ] = 0 ; 
      floorCallDown[ i ] = 0 ; 
         carPositionAbove[ i ] = 0 ; 
         carPositionLabel[ i ] = floorLabels[ groundFloor ] ;
         doorPosition[ i ] = doorClosed ;
      }
      if ( useNamedPipes ) {
         invoke( ( COROUTINE )pipeHandler, 0 ) ;
         coresume() ; 
      }
   }
   while ( !orderlyStop ) {
      // Check for any notifications for controller in the queue.
      if ( !notification_Q.IsEmpty() && notification_Q.IsFor() == controller ) {
         notification_Q.PopNotification( theNotification, sender, destination,
                               data0, data1, data2, data3 ) ;
         switch ( theNotification ) {
            case CAR_AVAILABLE :
               availableCars |= ( 1 << sender ) ;
               break ;
      
            case CAR_NOT_AVAILABLE :
               availableCars &= ~( 1 << sender ) ;
               break ;
      
            case CAR_SERVICING_FLOOR :
               servicingFloorCars |= ( 1 << sender ) ;
               break ;
      
            case CAR_NOT_SERVICING_FLOOR :
               servicingFloorCars &= ~( 1 << sender ) ;
               break ;
      
            case CAR_POSITION :
               {
                  carPositionAbove[ sender ] = data0 ;
                  carPositionLabel[ sender ] = data1 ;
                  direction carDir           = direction( data2 ) ;
      
                  //#define SHOW_INTERMEDIATE_POSITIONS
                  #ifdef SHOW_INTERMEDIATE_POSITIONS
                  if ( useNamedPipes && carPositionAbove[ sender ] != 0 ) {
                     // NB: just for a single car (e.g., 7).
                     const int noteBufLen = sizeof carLocation + 2 ;
                     static char noteBuf[ noteBufLen ] ; // includes '\n' + '\0'
                     noteBuf[ 0 ] = 'a' ;                // note id
                     noteBuf[ 1 ] = data1 ;              // floor
                     noteBuf[ 2 ] = data0 + '0' ;        // position above
                     noteBuf[ 3 ] = '\n' ;
                     noteBuf[noteBufLen - 1] = '\0' ;
                     write( statusPipeFd, noteBuf, strlen( noteBuf ) ) ;
                  }
                  #endif // def SHOW_INTERMEDIATE_POSITIONS
      
                  // Check to see if the car has reached a target floor.
                  if ( carPositionAbove[ sender ] == 0 ) {
                     if ( useNamedPipes ) {
                        const int noteBufLen = sizeof carLocation + 2 ;
                        static char noteBuf[ noteBufLen ] ; // includes '\n' + '\0'
                        noteBuf[ 0 ] = carLocation[ 0 ] ;   // note id
                        noteBuf[ 1 ] = data1 ;              // floor
                        noteBuf[ 2 ] = sender + '0' ;       // car
                        noteBuf[ 3 ] = '\n' ;
                        noteBuf[noteBufLen - 1] = '\0' ;
                        write( statusPipeFd, noteBuf, strlen( noteBuf ) ) ;
                        #ifdef VERBOSE_CONFIGURATION
                        {
                           char str[ 80 ] ; // ample
                           sprintf( str, "Written via pipe (%li chars)> noteBuf: "
                                         "'%s'", strlen( noteBuf ), noteBuf ) ;
                           cout << str << endl ;
                        }
                        #endif // def VERBOSE_CONFIGURATION
                     }
      
                     char *floorLabel = strchr( floorLabels,
                                                carPositionLabel[ sender ] ) ;
                     int floorIndex   = floorLabel - floorLabels ;
                     int tempFloors ;
                     if ( carDir == up ) {
                        tempFloors = floorCallUp[ sender ] ;
                     } else { // carDir == down
                        tempFloors = floorCallDown[ sender ] ;
                     }
                     tempFloors |= carButtons[ sender ] ;
                     if ( tempFloors & ( 1 << floorIndex ) ) {
                        // Turn off the floor button, just in case it is on. We'll
                        // turn off the 'down' button on the top floor or the 'up'
                        // button on the bottom floor.
                        int  floorLabelRow = floorLabelRows[ floorIndex ] ;
                        direction tempDir = carDir ;
                        if ( floorIndex == numberOfFloors - 1 ) {
                           tempDir = down ;
                        } else if ( floorIndex == 0 ) {
                           tempDir = up ;
                        }
                        pushFloorButton( false, tempDir, udButtonColumn,
                                         floorLabelRow ) ;
      
                        // Turn off our record of the car target and floor call.
                        carButtons[sender] &= ~( 1 << floorIndex ) ;
                        if ( tempDir == up ) {
                           floorCallUp[ sender ] &= ~( 1 << floorIndex ) ;
                        } else { // tempDir == down
                           floorCallDown[ sender ] &= ~( 1 << floorIndex ) ;
                        }
                     }
                  }
                  drawCar( sender, carPositionAbove[ sender ],
                           carPositionLabel[ sender ],
                           floorLabels, floorLabelRows, carButtons[ sender ],
                           carDir, groundFloorRow
                           #ifdef SHOW_AVAILABILITY
                           , availableCars & ( 1 << sender )
                           #endif // def SHOW_AVAILABILITY
                        ) ;
               }
               break ;
      
            case DOOR_POSITION :
               {
                  doorPosition[ sender ] = openness( data0 ) ;
                  char *pFloorLabel = strchr( floorLabels,
                                              carPositionLabel[ sender ] ) ;
                  int floorIndex = pFloorLabel - floorLabels ;
      
                  if ( useNamedPipes ) {
                     char doorStatus ;
                     switch ( openness( data0 ) ) {
                        case doorLocked :
                           doorStatus = ' ' ;
                           break ;
      
                        case doorClosed :
                           doorStatus = '|' ;
                           break ;
      
                        case doorOpen :
                        case doorOpenWaiting :
                           doorStatus = 'O' ;
                           break ;
      
                        case doorHalfClosed :
                        case doorHalfOpen :
                           doorStatus = '-' ;
                           break ;
      
                        default :
                           doorStatus = '?' ;
                           // **??** TBD Put an alert here. **??**
                     }
                     const int noteBufLen = sizeof doorIsClosed + 2 ;
                     static char noteBuf[ noteBufLen ] ; // includes '\n' + '\0'
                     noteBuf[ 0 ] = doorIsClosed[ 0 ] ;  // note id
                     noteBuf[ 1 ] = doorStatus ;         // door status
                     noteBuf[ 2 ] = sender + '0' ;       // car
                     noteBuf[ 3 ] = '\n' ;
                     noteBuf[noteBufLen - 1] = '\0' ;
                     write( statusPipeFd, noteBuf, strlen( noteBuf ) ) ;
                     #ifdef VERBOSE_CONFIGURATION
                     {
                        char str[ 80 ] ; // ample
                        sprintf( str, "Written via pipe (%li chars)> noteBuf: "
                                      "'%s'", strlen( noteBuf ), noteBuf ) ;
                        cout << str << endl ;
                     }
                     #endif // def VERBOSE_CONFIGURATION
                  }
                  if ( openness( data0 ) != doorLocked ) {
                     drawOpenDoor( floorLabelRows[ floorIndex ] - 2,
                                   MAX_FLOOR_LABEL_WIDTH
                                   + MAX_DOOR_WIDTH * ( sender - 1 ) + 3,
                                   openness( data0 ) ) ;
                  }
               }
               break ;
      
            case SHOW_UP_DOWN_INDICATOR :
               {
                  direction tempDir = direction( data1 ) ;
                  if ( tempDir == none ) {
                     // Accept the value 'none'.
                  } else if ( data0 == numberOfFloors - 1 ) {
                     tempDir = down ;
                  } else if ( data0 == 0 ) {
                     tempDir = up ;
                  }
                  if ( useNamedPipes ) {
                     char dirIndicator ;
                     switch ( tempDir ) {
                        case none :
                           dirIndicator = ' ' ;
                           break ;
      
                        case down :
                           dirIndicator = 'v' ;
                           break ;
      
                        case up :
                           dirIndicator = '^' ;
                           break ;
      
                        default:
                           dirIndicator = '?' ;
                           // **??** TBD Put an alert here. **??**
                     }
                     const int noteBufLen = sizeof indicatorIsDown + 2 ;
                     static char noteBuf[ noteBufLen ] ;   // includes '\n', '\0'
                     noteBuf[ 0 ] = indicatorIsDown[ 0 ] ; // note id
                     noteBuf[ 1 ] = dirIndicator ;         // dir indicator
                     noteBuf[ 2 ] = sender + '0' ;         // car
                     noteBuf[ 3 ] = '\n' ;
                     noteBuf[ noteBufLen - 1 ] = '\0' ;
                     write( statusPipeFd, noteBuf, strlen( noteBuf ) ) ;
                     #ifdef VERBOSE_CONFIGURATION
                     {
                        char str[ 80 ] ; // ample
                        sprintf( str, "Written via pipe (%li chars)> noteBuf: "
                                      "'%s'", strlen( noteBuf ), noteBuf ) ;
                        cout << str << endl ;
                     }
                     #endif // def VERBOSE_CONFIGURATION
                  }
                  drawUpDownIndicator( floorLabelRows[ data0 ] - 2,
                                       MAX_FLOOR_LABEL_WIDTH
                                        + MAX_DOOR_WIDTH * ( sender - 1 ) + 3,
                                       tempDir ) ;
                  if ( tempDir != none ) {
                     beep() ;
                  }
               }
               break ;
      
            default :
               break ; // **??** TBD Put an alert here. **??**
         }
      }
      coresume() ;
      // We give the user a chance to see the command before erasing it,
      // and without delaying the rest of the elevator simulation.
      if ( waitingToClearCommand ) {
         gettimeofday( &tv, (struct timezone *)NULL ) ;
         unsigned int currentTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;
         if ( currentTimeMs >= commandEraseTimeMs
            // Stop displaying command if another command arrives from the test
            // so as not to delay execution of the arriving command.
           || ( useNamedPipes && xkbhit() ) ) {
            commandOffset = 0 ;
            wmove( w, nrows - 1, commandPosition ) ;
            wclrtoeol( w ) ; // clear the rest of the command line
            wrefresh( w ) ;
            waitingToClearCommand = false ;
         }
        // Check for any input from the user.
      } else if ( ( useNamedPipes && xkbhit() ) || ( !useNamedPipes && kbhit() ) ) {
         int c ;
         if ( useNamedPipes ) {
            c = xgetch( );   // simulated
         } else {
            c = wgetch( w ) ;
         }
         if ( c == 'q' || c == 'z' ) {
            if ( c == 'z' ) {
               // The user has requested to end test processing, so we'll
               // exit with a non-zero code.  This will stop the repeated
               // execution of the goes.rb script.
               exitCode = USER_REQUESTED_EXIT ;
            }
      
            mvwaddstr( w, nrows - 1, commandPosition, "quit" ) ;
            wclrtoeol( w ) ; // clear the rest of the command line
            wrefresh( w ) ;
            orderlyStop = true ;
            wait( 1000 ) ;   // give the user a chance to see the quit command
            if ( useNamedPipes ) {
               char str[ SAFE_SIZE ] ;
               sprintf( str, "%s\n", P_END ) ;
               write( statusPipeFd, str, strlen( str ) ) ;
            }
         } else if ( c == 0x7f ) { // ncurses backspace key (by experimentation)
            if ( waitingForButtonLabel ) {
               // Wipe out the command that was entered.
               commandOffset-- ;
               mvwdelch( w, nrows - 1, commandPosition + commandOffset ) ;
               wrefresh( w ) ;
      
               // Now there is no command: "Command: ".
               waitingForButtonLabel = false ;
            } else if ( waitingForCarNumber ) {
               // Back out the car number that was entered.
               commandOffset-- ;
               mvwdelch( w, nrows - 1, commandPosition + commandOffset ) ;
               wrefresh( w ) ;
      
               waitingForCarNumber = false ;
               waitingForButtonLabel = true ;
            } else if ( waitingForDirection ) {
               // Back out the floor that was entered.
               commandOffset-- ;
               mvwdelch( w, nrows - 1, commandPosition + commandOffset ) ;
               wrefresh( w ) ;
      
               // For example, here is the command so far: "Command: F".
               waitingForDirection  = false ;
               waitingForFloorLabel = true ;
      
            } else if ( waitingForFloorLabel ) {
               // Wipe out the command that was entered.
               commandOffset-- ;
               mvwdelch( w, nrows - 1, commandPosition + commandOffset ) ;
               wrefresh( w ) ;
      
               // Now there is no command: "Command: ".
               waitingForFloorLabel = false ;
            } else if ( waitingForFirstDigit ) {
               // Wipe out the command that was entered.
               commandOffset-- ;
               mvwdelch( w, nrows - 1, commandPosition + commandOffset ) ;
               wrefresh( w ) ;
      
               // Now there is no command: "Command: ".
               waitingForFirstDigit = false;
            } else if ( waitingForSecondDigit ) {
               // Back out the first digit that was entered.
               commandOffset-- ;
               mvwdelch( w, nrows - 1, commandPosition + commandOffset ) ;
               wrefresh( w ) ;
      
               // For example, here is the command so far: "Command: X".
               waitingForFirstDigit  = true ;
               waitingForSecondDigit = false ;
      
            } else if ( waitingForEnter ) {
               // Back out the second digit that was entered.
               commandOffset-- ;
               mvwdelch( w, nrows - 1, commandPosition + commandOffset ) ;
               wrefresh( w ) ;
      
               // Restore the previous time multiplier.
               timeMultiplier = previousTimeMultiplier ;
               partialTimeMultiplier /= 10 ;
      
               // For example, here is the command so far: "Command: X1".
               waitingForEnter = false ;
               waitingForSecondDigit = true ;
      
            } else {
               // Tell the user that there isn't anything to backspace over.
               beep() ;
            }
         } else if ( waitingForButtonLabel ) {
            if ( strchr( floorLabels, c ) == NULL
              && strchr( floorLabels, toupper( c ) ) == NULL ) {
               // Tell user that she didn't input a button label.
               beep() ;
            } else {
               if ( strchr( floorLabels, c ) == NULL ) {
                  // The button label is uppercase, even though the user used
                  // lower case.
                  c = toupper( c ) ;
               }
               mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
               wrefresh( w ) ;
      
               // For example, here is the command so far: "Command: C2".
               theFloor = c ;
               waitingForButtonLabel = false ;
               waitingForCarNumber  = true ;
            }
         } else if ( waitingForCarNumber ) {
            int carNumber ;
            if ( c == '*' ) {
               carNumber = 0 ;
            } else {
               carNumber = c - '0' ;
            }
      
            // Ensure that the user entered a valid car number.
            if ( carNumber < 0 || carNumber > numberOfElevators ) {
               // Tell user that she didn't input a valid car number.
               beep() ;
            } else {
               mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
               wrefresh( w ) ;
      
               int startCar ;
               int endCar ;
               if ( carNumber == 0 ) {
                  // We'll send the request to all cars.
                  startCar = 1 ;
                  endCar   = numberOfElevators ;
               } else {
                  // We'll send the request just to the indicated car.
                  startCar = carNumber ;
                  endCar   = carNumber ;
               }
               for ( int i = startCar; i <= endCar; i++ ) {
                  // We'll ignore a pushed button in a stopped car for the
                  // floor that the car is currently on if the car is already
                  // in the process of serving the floor.
                  if ( carPositionAbove[ i ] != 0
                    || carPositionLabel[ i ] != theFloor
                    || !( servicingFloorCars & ( 1 << i ) ) ) {
                     // Send the notification to push a button in the elevator car.
                     char *floorLabel = strchr( floorLabels, theFloor ) ;
                     int floorIndex  = floorLabel - floorLabels ;
                     notification_Q.PushNotification( PUSH_CAR_BUTTON, controller,
                                            Component( i ), floorIndex,
                                            dummy, dummy, dummy ) ;
      
                     // Remember that the we're turning on the button in
                     // the car.
                     carButtons[ i ] |= ( 1 << floorIndex ) ;
      
                     // Update the elevator simulation display by lighting the
                     // button.
                     floorLabel = strchr( floorLabels, carPositionLabel[ i ] ) ;
                     floorIndex  = floorLabel - floorLabels ;
      
                     int floorLabelRow = floorLabelRows[ floorIndex ] ;
                     pushCarButton( true, i, theFloor,
                                    carPositionAbove[ i ], floorLabelRow ) ;
                  }
                  #define DEBUGGING
                  #ifdef DEBUGGING
                  else {
                     // For debugging purposes, we'll send a "CXi" message
                     // indicating that a button press wasn't available while
                     // the car is on the same floor.
                     if ( useNamedPipes ) {
                        const int noteBufLen = sizeof pushCarButtonCommand + 2 ;
                        static char noteBuf[ noteBufLen ] ; // includes "\n\0"
                        noteBuf[ 0 ] = pushCarButtonCommand[ 0 ] ; // note id
                        noteBuf[ 1 ] = 'X' ;                // 'invalid'
                        noteBuf[ 2 ] = i + '0' ;            // car
                        noteBuf[ 3 ] = '\n' ;
                        noteBuf[ noteBufLen - 1 ] = '\0' ;
                        write( statusPipeFd, noteBuf, strlen( noteBuf ) ) ;
                        #ifdef VERBOSE_CONFIGURATION
                        {
                           char str[ 80 ] ; // ample
                           sprintf( str, "Written via pipe (%li chars)> noteBuf: "
                                         "'%s'", strlen( noteBuf ), noteBuf ) ;
                           cout << str << endl ;
                        }
                        #endif // def VERBOSE_CONFIGURATION
                     }
                  }
                  #endif // DEBUGGING
               }
      
               // We'll erase the command in a bit, after the user sees it.
               gettimeofday( &tv, (struct timezone *)NULL ) ;
               commandEraseTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000
                                  + DELAY_BEFORE_ERASING_COMMAND ;
      
               // For example, here is the complete command: "Command: C21".
               waitingForCarNumber  = false ;
               waitingToClearCommand = true ;
            }
         } else if ( waitingForFirstDigit ) {
            int theDigit = c - '0' ;
            if ( theDigit >= 1 && theDigit <= 9 ) {
               mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
               wrefresh( w ) ;
      
               partialTimeMultiplier = theDigit ;
      
               // For example, here is the command so far: "Command: X1".
               waitingForFirstDigit  = false ;
               waitingForSecondDigit = true ;
            } else {
               // Tell user that she didn't input a digit (1 to 9).
               beep() ;
            }
         } else if ( waitingForSecondDigit ) {
            if ( c == 0x0d ) { // the enter key (by experimentation)
               mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
               wrefresh( w ) ;
               timeMultiplier = partialTimeMultiplier ;
      
               // Show the time multiplier if it not 1;
               if ( timeMultiplier == 1 ) {
                  mvwprintw( w, nrows - 1, 2, "    " ) ;
               } else {
                  mvwprintw( w, nrows - 1, 2, "X%i", timeMultiplier ) ;
               }
      
               // For example, here is the complete command:
               // "Command: X1<enter>".
               waitingForSecondDigit = false ;
               waitingToClearCommand = true ;
            } else {
               int theDigit = c - '0' ;
               if ( theDigit >= 0 && theDigit <= 9 ) {
                  mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
                  wrefresh( w ) ;
      
                  previousTimeMultiplier = timeMultiplier ;
                  timeMultiplier = partialTimeMultiplier * 10 + theDigit ;
      
                  // For example, here is the command so far: "Command: X10".
                  waitingForEnter       = true ;
                  waitingForSecondDigit = false ;
               } else {
                  // Tell user that she didn't input a digit (0 to 9).
                  beep() ;
               }
            }
         } else if ( waitingForEnter ) {
            if ( c == 0x0d ) { // the curses enter key (by experimentation)
               mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
               wrefresh( w ) ;
      
               // Show the time multiplier if it not 1;
               if ( timeMultiplier == 1 ) {
                  mvwprintw( w, nrows - 1, 2, "    " ) ;
               } else {
                  mvwprintw( w, nrows - 1, 2, "X%i", timeMultiplier ) ;
               }
      
               // For example, here is the complete command:
               // "Command: X10<enter>".
               waitingForEnter = false ;
               waitingToClearCommand = true ;
            } else {
               // Tell user that she didn't input the enter key.
               beep() ;
            }
         } else if ( waitingForDirection ) {
            // Start with the floor label as entered by the user.
            char *floorLabel = strchr( floorLabels, theFloor ) ;
            int floorIndex  = floorLabel - floorLabels ;
            c = toupper( c ) ;
            if ( ( c != 'U' && c != 'D' )
              || ( c == 'U' && floorIndex == ( numberOfFloors - 1 ) )
              || ( c == 'D' && floorIndex == 0 ) ) {
               // Tell user that she didn't input a direction, or the
               // direction isn't valid for the floor.
               beep() ; 
            } else {
               theDirection = ( c == 'U' ) ? up : down ; 
      
               mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
               wrefresh( w ) ;
      
               // Pick a car to handle this floor button request.  We pick the
               // car by priority:
               //   1. closest available car to target floor
               //   2. closest car traveling towards the target floor
               //   3. car traveling in opposite direction with nearest final
               //      target destination
               int selectedCarNumber  = 0 ; // invalid default
               int distanceCarToFloor = 9 ; // worst-case default
               char *pCarFloorLabel ;
               int carFloorIndex ;
               for ( int i = 1; i <= numberOfElevators; i++ ) {
                  if ( availableCars & ( 1 << i ) ) {
                     pCarFloorLabel = strchr( floorLabels,
                                              carPositionLabel[ i ] ) ;
                     carFloorIndex  = pCarFloorLabel - floorLabels ;
                     if ( abs( floorIndex - carFloorIndex )
                               < distanceCarToFloor ) {
                        // OK, we'll select the closest available car.
                        selectedCarNumber = i ;
                        distanceCarToFloor = abs( floorIndex - carFloorIndex ) ;
                     }
                  }
               }
               if ( !selectedCarNumber ) {
                  // We didn't find an available car, so we'll try to find
                  // one approaching the target floor.
                  selectedCarNumber = 3 ; // **??** TBD Just fake it for now. **??**
               }
      
      
               // Now send a notification to the chosen car to add this target to
               // its list.
               notification_Q.PushNotification( FLOOR_CALL, controller,
                                      Component( selectedCarNumber ),
                                      floorIndex, theDirection, dummy, dummy ) ;
      
               // Remember that the we're requesting that this car handle
               // the floor call request.
               if ( theDirection == up ) {
                  floorCallUp[ selectedCarNumber ] |= ( 1 << floorIndex ) ;
               } else { // theDirection == down
                  floorCallDown[ selectedCarNumber ] |= ( 1 << floorIndex ) ;
               }
      
               // Update the elevator simulation display by lighting the button.
               int  floorLabelRow = floorLabelRows[ floorIndex ] ;
               pushFloorButton( true, theDirection, udButtonColumn,
                                floorLabelRow ) ;
      
               // We'll erase the command in a bit, after the user sees it.
               gettimeofday( &tv, (struct timezone *)NULL ) ;
               commandEraseTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000
                                  + DELAY_BEFORE_ERASING_COMMAND ;
      
               // For example, here is the complete command: "Command: F2D".
               waitingForDirection   = false ;
               waitingToClearCommand = true ;
            }
         } else if ( waitingForFloorLabel ) {
            if ( strchr( floorLabels, c ) == NULL
              && strchr( floorLabels, toupper( c ) ) == NULL ) {
               // Tell user that she didn't input a floor label.
               beep() ;
            } else {
               if ( strchr( floorLabels, c ) == NULL ) {
                  // The floor label is uppercase, even though the user used
                  // lower case.
                  c = toupper( c ) ;
               }
               mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
               wrefresh( w ) ;
      
               // For example, here is the command so far: "Command: F2".
               theFloor = c ;
               waitingForFloorLabel = false ;
               waitingForDirection  = true ;
            }
         } else if ( ( c = toupper( c ) ) == 'F' ) {
            mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
            wrefresh( w ) ;
      
            // Here is the command so far: "Command: F".
            waitingForFloorLabel = true ;
         } else if ( ( c = toupper( c ) ) == 'C' ) {
            mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
            wrefresh( w ) ;
      
            // Here is the command so far: "Command: C".
            waitingForButtonLabel = true ;
         } else if ( ( c = toupper( c ) ) == 'H' ) {
         } else if ( ( c = toupper( c ) ) == 'X' ) {
            mvwaddch( w, nrows - 1, commandPosition + commandOffset++, c ) ;
            wrefresh( w ) ;
      
            // Here is the command so far: "Command: X".
            waitingForFirstDigit = true ;
         } else {
            // Tell user that she didn't input a command.
            beep() ;
         }
      }
      coresume() ;
   }
   // Pause for the user to read any error messages.
   if ( shouldPause ) {
      curRow++ ; // blank line between messages
      mvwaddstr( w, curRow++, 3, "Press any key to continue..." ) ;
      wrefresh( w ) ;
      while( kbhit() == false ) {
         wait( 500 ) ; // ms
      }
      wgetch( w ) ; // collect the character
   }
}
void car( int shaft ) {
   char      atFloor ;
   int       buttons               = 0 ;
   int       floorIndex ;
   int       floorStopRequestsDown = 0 ;
   int       floorStopRequestsUp   = 0 ;
   bool      moving                = false ;
   direction myDir                 = up ;   // initial direction
   openness  nextDoorState         = doorClosed ; // initial state
   int       position              = 0 ;
   bool      waitingForDoor        = false ;

   // We'll start out on the ground floor.
   atFloor = floorLabels[ groundFloor ] ;
   char *pGroundFloorLabel = strchr( floorLabels, atFloor ) ;
   floorIndex              = pGroundFloorLabel - floorLabels ;

   // Tell the simulation controller that we are available.
   notification_Q.PushNotification( CAR_AVAILABLE, Component( shaft ), controller,
                          dummy, dummy, dummy, dummy ) ;

   // Tell the simulation controller that we are not servicing floors.
   notification_Q.PushNotification( CAR_NOT_SERVICING_FLOOR, Component( shaft ),
                          controller, dummy, dummy, dummy, dummy ) ;

   // Tell the simulation controller (elevatorSimulation) where we are.
   notification_Q.PushNotification( CAR_POSITION, Component( shaft ), controller,
                          position, atFloor, myDir, dummy ) ;

   // Behave like an elevator until the simulation ends.
   unsigned int currentTimeMs ;
   unsigned int doorPositionTimeMs ;
   unsigned int positionReachedTimeMs ;
   struct timeval tv ;
   while ( !orderlyStop ) {
      if ( waitingForDoor ) {
         gettimeofday( &tv, (struct timezone *)NULL ) ;
         currentTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;

         if ( currentTimeMs >= doorPositionTimeMs ) {
            if ( nextDoorState != doorOpenWaiting ) {
               // Tell the simulation controller our door position.
               notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                      controller, nextDoorState,
                                      dummy, dummy, dummy ) ;
            }

            switch ( nextDoorState ) {
               case doorHalfOpen :
                  nextDoorState = doorOpen ;
                  doorPositionTimeMs = currentTimeMs
                                     + doorTransitTime / timeMultiplier ;
                  break ;

               case doorOpen :
                  nextDoorState = doorOpenWaiting ;
                  doorPositionTimeMs = currentTimeMs
                                     + doorRemainsOpenTime / timeMultiplier ;
                  break ;

               case doorOpenWaiting :
                  nextDoorState = doorHalfClosed ;
                  doorPositionTimeMs = currentTimeMs
                                     + doorTransitTime / timeMultiplier ;
                  break ;

               case doorHalfClosed :
                  nextDoorState = doorClosed ;
                  doorPositionTimeMs = currentTimeMs
                                     + doorTransitTime / timeMultiplier ;
                  break ;

               case doorClosed :
                  waitingForDoor = false ;

                  // Tell the simulation controller that we are finished
                  // servicing this floor.
                  notification_Q.PushNotification( CAR_NOT_SERVICING_FLOOR,
                                         Component( shaft ), controller,
                                         dummy, dummy, dummy, dummy ) ;

                  // Set the time for the first position arrival if we are
                  // going to move as soon as the door closes.
                  if ( moving ) {
                     positionReachedTimeMs = currentTimeMs
                                           + positionTransitionTime
                                                               / timeMultiplier ;

                     // Tell the simulation controller our door is now locked.
                     notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                            controller, doorLocked,
                                            dummy, dummy, dummy ) ;
                  }

                  // Tell the controller to turn off the direction indicator.
                  notification_Q.PushNotification( SHOW_UP_DOWN_INDICATOR,
                                         Component( shaft ),
                                         controller, floorIndex, none,
                                         dummy, dummy ) ;

                  if ( !buttons && !floorStopRequestsUp
                    && !floorStopRequestsDown ) {
                     notification_Q.PushNotification( CAR_AVAILABLE, Component( shaft ),
                                            controller,
                                            dummy, dummy, dummy, dummy ) ;
                     #ifdef SHOW_AVAILABILITY
                     // Tell the simulation controller where we are.
                     notification_Q.PushNotification( CAR_POSITION, Component( shaft ),
                                            controller, position, atFloor,
                                            myDir, dummy ) ;
                     #endif // def SHOW_AVAILABILITY
                  }
                  break ;

               case doorLocked :
                  // This should not occur.
                  // The case is included to avoid a clang compiler warning.
                  break ;
            }
         }
      } else if ( moving ) {
         bool targetReached = false ; // default
         bool extentReached = false ; // default
         gettimeofday( &tv, (struct timezone *)NULL ) ;
         currentTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;
         if ( currentTimeMs >= positionReachedTimeMs ) {
            // We've reached a positional change. We'll update our records
            // and notify the simulation controller so it can draw our updated
            // position. We always leave position with a zero value following
            // a transfer (i.e., position == 0 => we're on a floor boundary).
            if ( myDir == up ) {
               if ( ++position == MAX_DOOR_HEIGHT ) {
                  position = 0 ;
                  floorIndex++ ;
                  atFloor = floorLabels[ floorIndex ];
                  if ( buttons & ( 1 << floorIndex )
                    || floorStopRequestsUp & ( 1 << floorIndex ) )
                  {
                     targetReached = true ;
                  } else {
                     // Check for any targets above.
                     bool found = false ;
                     for ( int i = floorIndex + 1; i < numberOfFloors; i++ ) {
                        if ( buttons & ( 1 << i )
                          || floorStopRequestsUp & ( 1 << i ) ) {
                           found = true ;
                           break ;
                        }
                     }

                     // If there aren't any targets, see if there are
                     // pending floor down requests for me above this floor.
                     if ( !found ) {
                        for ( int i = floorIndex + 1; i < numberOfFloors; i++ ) {
                           if ( floorStopRequestsDown & ( 1 << i ) ) {
                              found = true ;
                              break ;
                           }
                        }
                        if ( !found ) {
                           // There aren't any stops for me above, so this is
                           // the time to turn around, if there are any stops
                           // below.
                           extentReached = true ;
                        }
                     }
                  }
               }
            } else { // myDir == down
               if ( position == 0 ) {
                  position = MAX_DOOR_HEIGHT - 1 ;
                  floorIndex-- ;
                  atFloor = floorLabels[ floorIndex ] ;
               } else if ( --position == 0 ) {
                  if ( buttons & ( 1 << floorIndex )
                    || floorStopRequestsDown & ( 1 << floorIndex ) ) {
                     targetReached = true ;
                  } else {
                     // Check for any targets below.
                     bool found = false ;
                     for ( int i = floorIndex - 1; i >= 0; i-- ) {
                        if ( buttons & ( 1 << i )
                          || floorStopRequestsDown & ( 1 << i ) ) {
                           found = true ;
                           break ;
                        }
                     }

                     // If there aren't any targets, see if there are
                     // pending floor up requests for me below this floor.
                     if ( !found ) {
                        for ( int i = floorIndex - 1; i >= 0; i-- ) {
                           if ( floorStopRequestsUp & ( 1 << i ) ) {
                              found = true ;
                              break ;
                           }
                        }
                        if ( !found ) {
                           // There aren't any stops for me below, so this is
                           // the time to turn around, if there are any stops
                           // above.
                           extentReached = true ;
                        }
                     }
                  }
               }
            }

            // Tell the simulation controller where we are.
            notification_Q.PushNotification( CAR_POSITION, Component( shaft ), controller,
                                   position, atFloor, myDir, dummy ) ;
            // Continue to move.
            positionReachedTimeMs = currentTimeMs
                                  + positionTransitionTime / timeMultiplier ;
         }

         // If we're at a target floor, we'll stop and open the door.
         if ( targetReached ) {
            // Tell the simulation controller that we are going to stop on
            // this floor and open the door.
            notification_Q.PushNotification( CAR_SERVICING_FLOOR,
                                   Component( shaft ), controller,
                                   dummy, dummy, dummy, dummy ) ;

            // Tell the simulation controller our door is now unlocked.
            notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                   controller, doorClosed,
                                   dummy, dummy, dummy ) ;

            // Tell the controller to turn on the direction indicator.
            notification_Q.PushNotification( SHOW_UP_DOWN_INDICATOR, Component( shaft ),
                                   controller, floorIndex, myDir,
                                   dummy, dummy ) ;

            // Remove the request for this stop.
            buttons &= ~( 1 << floorIndex ) ;
            if ( myDir == up ) {
               floorStopRequestsUp &= ~( 1 << floorIndex ) ;
            } else { // myDir == down
               floorStopRequestsDown &= ~( 1 << floorIndex ) ;
            }

            // Open the door.
            doorPositionTimeMs = currentTimeMs
                               + doorTransitTime / timeMultiplier ;
            moving             = false ;
            waitingForDoor     = true ;
            nextDoorState      = doorHalfOpen ;
         } else if ( extentReached ) {
            moving = false ;

            if ( !buttons && !floorStopRequestsUp && !floorStopRequestsDown ) {
               notification_Q.PushNotification( CAR_AVAILABLE, Component( shaft ),
                                      controller,
                                      dummy, dummy, dummy, dummy ) ;
               #ifdef SHOW_AVAILABILITY
               // Tell the simulation controller where we are.
               notification_Q.PushNotification( CAR_POSITION, Component( shaft ),
                                      controller, position, atFloor,
                                      myDir, dummy ) ;
               #endif // def SHOW_AVAILABILITY
            }
         }
      }

      coresume() ;

      // Check for any notification.
      if ( !notification_Q.IsEmpty() && notification_Q.IsFor() == shaft ) {
         char         data0 ;
         char         data1 ;
         char         data2 ;
         char         data3 ;
         Component    destination ;
         Component    sender ;
         Notification      theNotification ;
         notification_Q.PopNotification( theNotification, sender, destination,
                               data0, data1, data2, data3 ) ;
         switch ( theNotification ) {
            case FLOOR_CALL :
               {
                  direction tempDir = direction( data1 ) ;

                  // Add the floor stop call to our list.
                  if ( tempDir == up ) {
                     floorStopRequestsUp |= ( 1 << data0 ) ;
                  } else { // tempDir == down
                     floorStopRequestsDown |= ( 1 << data0 ) ;
                  }
               }
               break ; 

            case PUSH_CAR_BUTTON :

               // Add the button to our list.
               buttons |= ( 1 << data0 ) ;
               break ;

            default :
               break ; // **??** TBD Put an alert here. **??**
         }
      }

      coresume() ;

      if ( ( buttons || floorStopRequestsUp || floorStopRequestsDown )
        && !moving && !waitingForDoor ) {
         //#define CHECK_POSITION
         #ifdef CHECK_POSITION
         assert( position == 0 ) ;
         #endif // def CHECK_POSITION

         // We are not moving and we have a request.
         int *tempFloorRequest ;
         if ( myDir == up ) {
            tempFloorRequest = &floorStopRequestsUp ;
         } else { // myDir == down
            tempFloorRequest = &floorStopRequestsDown ;
         }
         if ( buttons & ( 1 << floorIndex )
           || *tempFloorRequest & ( 1 << floorIndex ) ) {
            // The request is for the floor we're currently on, so we'll just
            // open the door.  First, we'll clear this floor from our buttons
            // and floor stop requests.
            buttons &= ~( 1 << floorIndex ) ;
            *tempFloorRequest &= ~( 1 << floorIndex ) ;

            // Tell the simulation controller that we are going to open the door
            // and service this floor.
            notification_Q.PushNotification( CAR_SERVICING_FLOOR,
                                   Component( shaft ), controller,
                                   dummy, dummy, dummy, dummy ) ;

            // Tell the simulation controller our door is now unlocked.
            notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                   controller, doorClosed,
                                   dummy, dummy, dummy ) ;

            // Tell the controller to turn on the direction indicator.
            notification_Q.PushNotification( SHOW_UP_DOWN_INDICATOR, Component( shaft ),
                                   controller, floorIndex, myDir,
                                   dummy, dummy ) ;

            // Tell the controller to turn off the car and floor buttons.
            notification_Q.PushNotification( CAR_POSITION, Component( shaft ), controller,
                                   position, atFloor, myDir, dummy ) ;

            // Now, start opening the door.
            gettimeofday( &tv, (struct timezone *)NULL ) ;
            currentTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;
            doorPositionTimeMs = currentTimeMs
                               + doorTransitTime / timeMultiplier ;
            waitingForDoor = true ;
            nextDoorState = doorHalfOpen ;
         } else {
            if ( myDir == up ) {
               // Look for a target above our current position.
               for ( int i = floorIndex + 1; i < numberOfFloors; i++ ) {
                  if ( buttons & ( 1 << i )
                    || floorStopRequestsUp & ( 1 << i )
                    || floorStopRequestsDown & ( 1 << i ) ) {
                     moving         = true ;
                     notification_Q.PushNotification( CAR_NOT_AVAILABLE,
                                            Component( shaft ), controller,
                                            dummy, dummy, dummy, dummy ) ;

                     // Tell the simulation controller our door is now locked.
                     notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                            controller, doorLocked,
                                            dummy, dummy, dummy ) ;
                     break ;
                  }
               }
            } else { // myDir == down
               // Look for a target below our current position.
               for ( int i = floorIndex - 1; i >= 0; i-- ) {
                  if ( buttons & ( 1 << i )
                    || floorStopRequestsDown & ( 1 << i )
                    || floorStopRequestsUp & ( 1 << i ) ) {
                     moving         = true ;
                     notification_Q.PushNotification( CAR_NOT_AVAILABLE,
                                            Component( shaft ), controller,
                                            dummy, dummy, dummy, dummy ) ;

                     // Tell the simulation controller our door is now locked.
                     notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                            controller, doorLocked,
                                            dummy, dummy, dummy ) ;
                     break ;
                  }
               }
            }

            // If we didn't find a target in the present direction, then
            // we'll reverse direction.
            if ( !moving ) {
               int *tempFloorRequest ;
               if ( myDir == up ) {
                  myDir = down ;
                  tempFloorRequest = &floorStopRequestsDown ;
               } else {
                  myDir = up ;
                  tempFloorRequest = &floorStopRequestsUp ;
               }
               if ( buttons & ( 1 << floorIndex )
                 || *tempFloorRequest & ( 1 << floorIndex ) ) {
                  // The request is for the floor we're currently on, so we'll
                  // just open the door.  First, we'll clear this floor from
                  // our buttons and floor stop requests.
                  buttons &= ~( 1 << floorIndex ) ;
                  *tempFloorRequest &= ~( 1 << floorIndex ) ;

                  // Tell the simulation controller that we are going to open
                  // the door and service this floor.
                  notification_Q.PushNotification( CAR_SERVICING_FLOOR,
                                         Component( shaft ), controller,
                                         dummy, dummy, dummy, dummy ) ;

                  // Tell the simulation controller our door is now unlocked.
                  notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                         controller, doorClosed,
                                         dummy, dummy, dummy ) ;

                  // Tell the controller to turn on the direction indicator.
                  notification_Q.PushNotification( SHOW_UP_DOWN_INDICATOR,
                                         Component( shaft ),
                                         controller, floorIndex, myDir,
                                         dummy, dummy ) ;

                  // Tell the controller to turn off the car and floor buttons.
                  notification_Q.PushNotification( CAR_POSITION, Component( shaft ),
                                         controller, position, atFloor, myDir,
                                         dummy ) ;

                  // Now, start opening the door.
                  gettimeofday( &tv, (struct timezone *)NULL ) ;
                  currentTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;
                  doorPositionTimeMs = currentTimeMs
                                     + doorTransitTime / timeMultiplier ;
                  waitingForDoor = true ;
                  nextDoorState = doorHalfOpen ;
               } else {
                  moving         = true ;
                  notification_Q.PushNotification( CAR_NOT_AVAILABLE,
                                         Component( shaft ), controller,
                                         dummy, dummy, dummy, dummy ) ;

                  // Tell the simulation controller our door is now locked.
                  notification_Q.PushNotification( DOOR_POSITION, Component( shaft ),
                                         controller, doorLocked,
                                         dummy, dummy, dummy ) ;
               }
            }

            // Set the expected time of arrival at the next position.
            gettimeofday( &tv, (struct timezone *)NULL ) ;
            currentTimeMs = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;
            positionReachedTimeMs = currentTimeMs
                                  + positionTransitionTime / timeMultiplier ;
         }
      }

      coresume() ;
   }
}
void pipeHandler( void ) {
   char      buf[ MAX_BUF_SIZE ] ;
   int       count ;
   int       numRead ;
   char      *pBuf ;
   bool      pipeInputAvailable = false ;

   xgetchCharAvailable = false ;
   while ( !orderlyStop ) {
      if ( pipeInputAvailable ) {
         if ( !xgetchCharAvailable ) {
            // We'll hand a char to the simulation, unless it's a nul.
            xgetchChar = *pBuf++ ;
            if ( !xgetchChar ) {
               pipeInputAvailable = false ;
            } else {
               xgetchCharAvailable = true ;
            }
         }
      } else {
         // We don't have any input from the pipe, so let's check for some.
         // Note that this is a non-blocking request.
         numRead = read( commandPipeFd, buf, MAX_BUF_SIZE ) ;
         if ( numRead == -1 ) {
            if ( errno == EAGAIN ) {
               // No data was available from the pipe, so we'll wait a while
               // and then try again.
               wait( pipeCheckInterval ) ;
            } else {
               // An error has occurred with the pipe.
               // **??** TBD send an alert **??**
               orderlyStop = true ;
            }
         } else if ( numRead > 0 ) {
            buf[ numRead ] = '\0' ;
            pBuf = buf ; // initialized to start of data
            pipeInputAvailable = true ;
         }
      }

      coresume() ;
   }
}
void roundtripCounter( void ) {
   unsigned long coresumeCount = 0 ;
   unsigned int startTime ;
   unsigned int endTime ;
   struct timeval tv ;

   gettimeofday( &tv, (struct timezone *)NULL ) ;
   startTime = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;

   bool otherCoroutinesComplete = false ;
   while ( !otherCoroutinesComplete ) {
      #ifdef SHOW_HISTOGRAM
      itHistCR.tally();
      #endif // def SHOW_HISTOGRAM
      coresumeCount++ ;
      coresume() ;
      if ( orderlyStop && getCoroutineCount() < 2 ) {
         otherCoroutinesComplete = true ;
      }
   }

   gettimeofday( &tv, (struct timezone *)NULL ) ;
   endTime = tv.tv_sec * 1000 + tv.tv_usec / 1000 ;

   when( getCoroutineCount() < 2 ) {
      // This is the last running coroutine. The current coroutine
      // implementation requires returning from cobegin from a coroutine
      // with no calling parameters. Here we prepare a line to display after
      // leaving curses windowing.
      if ( endTime - startTime < 1000 ) {
         sprintf( roundtripCounterOutputString,
                  ">>> coresume cycle count: N/A." ) ;
      } else {
         sprintf( roundtripCounterOutputString,
                  ">>> coresume cycle count: %lu (%lu / sec).",
                  coresumeCount,
                  coresumeCount / ( ( endTime - startTime ) / 1000 ) ) ;
      }
   }
}
/*
 * elevator Utility Routines
 */
bool checkInput( int numberOfElevators, const char *floorSpecification,
                 int &numberOfFloors, int &grndFloor, char *floorLabels ) {
   bool brc        = true ; // assume success
   int  noOfFloors = 0 ; // invalid
   grndFloor       = 0 ; // default level
   if ( strlen( floorSpecification ) == 0 ) {
      cout << "Error: No floor labels specified.\r\n" ;
      return false ;
   }
   if ( numberOfElevators < MIN_NUMBER_OF_ELEVATORS
     || numberOfElevators > MAX_NUMBER_OF_ELEVATORS ) {
      cout << "Error: Elevator count must be between 1 and "
           << int( MAX_NUMBER_OF_ELEVATORS ) << ".\r\n" ;
      return false ;
   }
   const char *pFl          = floorSpecification ;
   bool groundFloorIsMarked = false ;
   bool waitingForEndDigit  = false ;
   int  mostRecentDigit     =  0; // invalid
   char temp[ 17 ] ; // ample for 1 digit
   floorLabels[ 0 ] = '\0' ;
   for ( int i = 0; i < strlen( floorSpecification ); i++ ) {
      if ( waitingForEndDigit ) {
         temp[ 0 ] = *pFl ;
         temp[ 1 ] = '\0' ;
         int endDigit = atoi( temp ) ;
         for ( int i = mostRecentDigit + 1; i <= endDigit; i++ ) {
            int flLen = strlen( floorLabels ) ;
            if ( flLen < MAX_NUMBER_OF_FLOORS ) {
               sprintf( temp, "%i", i );
               temp[ 1 ] = '\0' ;
               floorLabels[ flLen ] = temp[ 0 ] ;
               floorLabels[ flLen + 1 ] = '\0' ;
            } else {
               cout << "Error: Too many floor labels specified. The maximum is "
                    << int( MAX_NUMBER_OF_FLOORS ) << ".\r\n" ;
               return false ;
            }
         }
         waitingForEndDigit = false ;
      } else if ( isdigit( *pFl ) ) {
         temp[ 0 ] = *pFl ;
         temp[ 1 ] = '\0' ;
         mostRecentDigit = atoi( temp ) ;
         int flLen = strlen( floorLabels ) ;
         if ( flLen < MAX_NUMBER_OF_FLOORS ) {
            floorLabels[ flLen ] = *pFl ;
            floorLabels[ flLen + 1 ] = '\0' ;
         } else {
            cout << "Error: Too many floor labels specified. The maximum is "
                 << int( MAX_NUMBER_OF_FLOORS ) << ".\r\n" ;
            return false ;
         }
      } else if ( *pFl == '-' ) {
         waitingForEndDigit = true ;
      } else if ( *pFl == '#' ) {
         if ( groundFloorIsMarked ) {
            cout << "Error: Multiple ground floor specifications (#)."
                 << "\r\n" ;
            return false ;
         } else {
            grndFloor = strlen( floorLabels ) ;
            groundFloorIsMarked = true ;
         }
      } else if ( isalpha( *pFl ) ) {
         int flLen = strlen( floorLabels ) ;
         if ( flLen < MAX_NUMBER_OF_FLOORS ) {
            floorLabels[ flLen ] = *pFl ;
            floorLabels[ flLen + 1 ] = '\0' ;
         } else {
            cout << "Error: Too many floor labels specified. The maximum is "
                 << int( MAX_NUMBER_OF_FLOORS ) << ".\r\n" ;
            return false ;
         }
      } else {
         char str[ 80 ] ; // ample
         sprintf( str, "Unrecognized floor label specified: '%c'.", *pFl ) ;
         cout << str << "\r\n" ;
         return false ;
      }
      pFl++ ;
   }
   noOfFloors = strlen( floorLabels ) ;
   if ( noOfFloors < MIN_NUMBER_OF_FLOORS
     || noOfFloors > MAX_NUMBER_OF_FLOORS ) {
      cout << "Error: You must specify between 1 and "
           << int( MAX_NUMBER_OF_FLOORS ) << " floors.\r\n" ;
      brc = false ;
   } else {
      numberOfFloors = noOfFloors ;
   }

   return brc ;
}
void drawCar( int shaftNumber, int positionAbove, char theFloor,
              char floorLabels[], int floorLabelRows[], int buttonsPressed,
              direction theDirection, int groundFloorRow
              #ifdef SHOW_AVAILABILITY
              , bool available
              #endif // def SHOW_AVAILABILITY
            ) {
   char *floorLabel = strchr( floorLabels, theFloor ) ;
   int floorIndex   = floorLabel - floorLabels ;
   int topRow       = floorLabelRows[ floorIndex ] - positionAbove - 2 ;
   int leftColumn   = ( shaftNumber - 1 ) * MAX_DOOR_WIDTH
                        + MAX_FLOOR_LABEL_WIDTH ;

   // Erase the previous image.
   if ( theDirection == up ) {
      // Erase the bottom row of the previous image. Replace the ground floor
      // chars as required.
      mvwaddstr( w, topRow + 5, leftColumn,
                 ( topRow + 5 ) == groundFloorRow ? "===" : "   " ) ;
      mvwaddch( w, topRow + 5, leftColumn + MAX_DOOR_WIDTH - 2,
                ( topRow + 5 ) == groundFloorRow ? '=' : ' ' ) ;
   } else { // direction == down
      // Erase the top row of the previous image. Replace the ground floor
      // chars as required.
      mvwaddstr( w, topRow - 1, leftColumn,
                 ( topRow - 1 ) == groundFloorRow ? "===" : "   " ) ;
      mvwaddch( w, topRow - 1, leftColumn + MAX_DOOR_WIDTH - 2,
                ( topRow - 1 ) == groundFloorRow ? '=' : ' ' ) ;
   }

   // Now display the car at the current position.
   for ( int i = 0; i < CAR_HEIGHT; i++ ) {
      #ifdef SHOW_AVAILABILITY
      mvwaddch( w, topRow + i, leftColumn, ( !i && available ) ? 'a' : '*' ) ;
      #else
      mvwaddch( w, topRow + i, leftColumn, '*' ) ;
      #endif // def SHOW_AVAILABILITY
      if ( buttonsPressed & ( 1 << ( CAR_HEIGHT - 1 - i ) ) ) {
         waddch( w, floorLabels[ CAR_HEIGHT - 1 - i ] | COLOR_PAIR( 7 ) ) ;
      } else {
         waddch( w, ' ' ) ;
      }
      if ( buttonsPressed & ( 1 << ( 2 * CAR_HEIGHT - 1 - i ) ) ) {
         waddch( w, floorLabels[ 2 * CAR_HEIGHT - 1 - i ] | COLOR_PAIR( 7 ) ) ;
      } else {
         waddch( w, ' ' ) ;
      }
      mvwaddch( w, topRow + i, leftColumn + MAX_DOOR_WIDTH - 2, '*' ) ;
   }
   wrefresh( w ) ;
}
void drawOpenDoor( int y, int x, openness state ) {
   chtype doorPanel[ 4 ] ;

   doorPanel[ 0 ] = ' ' | ( state == doorOpen )   * A_REVERSE ;
   doorPanel[ 1 ] = ' ' | ( state != doorClosed ) * A_REVERSE ;
   doorPanel[ 2 ] = ' ' | ( state != doorClosed ) * A_REVERSE ;
   doorPanel[ 3 ] = ' ' | ( state == doorOpen )   * A_REVERSE ;

   // Draw the lines.
   for ( int i = 1; i <= 3; i++ ) {                              
      for ( int j = 1; j <= 4; j++ ) {
         mvwaddch( w, y + i, x + j, doorPanel[ j - 1 ] ) ;
      }
   }

   wrefresh( w ) ;
}
void drawUpDownIndicator( int y, int x, direction indicatorDir ) {
   chtype c ;

   if ( indicatorDir == up ) {
      c = '^' | COLOR_PAIR( 3 ) ; // bold green on white
   } else if ( indicatorDir == down ) {
      c = 'v' | COLOR_PAIR( 2 ) ; // bold red on white
   } else { //  indicatorDir == none
      c = ' ' ;
   }
   mvwaddch( w, y - 1, x + 3, c ) ;

   wrefresh( w ) ;
}
void initDoor( int y, int x ) {
   // Draw the top.
   mvwhline( w, y, x + 1, ACS_HLINE, 4 ) ;

   // Draw the left side.
   mvwvline( w, y + 1, x, ACS_VLINE, 3 ) ;

   // Draw the right side.
   mvwvline( w, y + 1, x + 5, ACS_VLINE, 3 ) ;

   // Draw the bottom.
   mvwhline( w, y + 4, x + 1, ACS_HLINE, 4 ) ;

   // Draw the upper-left corner.
   mvwaddch( w, y, x, ACS_ULCORNER ) ;

   // Draw the upper-right corner.
   mvwaddch( w, y, x + 5, ACS_URCORNER ) ;

   // Draw the lower-right corner.
   mvwaddch( w, y + 4, x + 5, ACS_LRCORNER ) ;

   // Draw the lower-left corner.
   mvwaddch( w, y + 4, x, ACS_LLCORNER ) ;
}
void pushCarButton( bool isOn, int shaft, char theCarButton,
                    int positionAbove, int floorLabelRow ) {
   int   buttonColumn ;
   int   buttonRow ;
   chtype theChar ;
   char  *floorLabel   = strchr( floorLabels, theCarButton ) ;
   int   floorIndex    = floorLabel - floorLabels ;
   int   topRow        = floorLabelRow - positionAbove - 2 ;
   int   carLeftColumn = ( shaft - 1 ) * MAX_DOOR_WIDTH + MAX_FLOOR_LABEL_WIDTH ;

   if ( floorIndex < CAR_HEIGHT ) {
      buttonColumn = carLeftColumn + 1 ;
      buttonRow    = topRow + CAR_HEIGHT - 1 - floorIndex ;
   } else { // floorIndex >= CAR_HEIGHT
      buttonColumn = carLeftColumn + 2 ;
      buttonRow    = topRow + 2 * CAR_HEIGHT - 1 - floorIndex ;
   }
   if ( isOn ) {
      theChar = theCarButton | COLOR_PAIR( 7 ) ; // black on bright yellow
   } else {
      theChar = theCarButton | COLOR_PAIR( 6 ) ; // black on light grey
   }
   mvwaddch( w, buttonRow, buttonColumn, theChar ) ;
   wrefresh( w ) ;
}
void pushFloorButton( bool isOn, direction theDirection,
                      int udButtonColumn, int floorLabelRow ) {
   chtype theChar ;
   if ( theDirection == up ) {
      if ( isOn ) {
         theChar = 'U' | COLOR_PAIR( 7 ) ; // black on bright yellow
      } else {
         theChar = 'U' | COLOR_PAIR( 6 ) ; // black on light grey
      }

      mvwaddch( w, floorLabelRow - 1, udButtonColumn, theChar ) ;
   } else { // theDirection is down
      if ( isOn ) {
         theChar = 'D' | COLOR_PAIR( 7 ) ; // black on bright yellow
      } else {
         theChar = 'D' | COLOR_PAIR( 6 ) ; // black on light grey
      }

      mvwaddch( w, floorLabelRow, udButtonColumn, theChar ) ;
   }
   wrefresh( w ) ;
}
char *strupr( char *string ) {
   int strLen = strlen( string ) ;
   for ( int i = 0; i < strLen; i++ ) {
      string[ i ] = toupper( string[ i ] ) ;
   }
   return string ;
}
int  xgetch( void ) {
   xgetchCharAvailable = false ;
   return xgetchChar ;
}
bool xkbhit( void ) {
   return xgetchCharAvailable ;
}
