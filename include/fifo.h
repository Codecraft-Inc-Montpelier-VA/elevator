/*
 * DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
 */
/*

 * Copyright (c) 2003 - 2021 Codecraft, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/*
 *++
 * Project:
 *   +elevator+ -- a test program for coroutines and ncurses.  <by Cary WR Campbell>
 *
 * Module:
 *   +Notification+ header and +Fifo+ queueing class file for message passing between
 *   +elevator+ simulation +Components+.
 *--
 */
/* 
 * Constants and Typedefs
 */
typedef enum Component {
   broadcast = 0,
   car1,
   car2,
   car3,
   car4,
   car5,
   car6,
   car7,
   car8,
   car9,
   controller
} Component ;
typedef enum Notification {      
   CAR_POSITION = 0,   
   CAR_AVAILABLE,           
   CAR_NOT_AVAILABLE,       
   CAR_SERVICING_FLOOR,     
   CAR_NOT_SERVICING_FLOOR, 
   DOOR_POSITION,           
   FLOOR_CALL,              
   PUSH_CAR_BUTTON,         
   SHOW_UP_DOWN_INDICATOR   
} Notification ;
const int NUMBER_OF_FIFO_BUFFER_SLOTS = 50 ;
typedef struct {
   Notification   theNotification ;
   Component source ;
   Component destination ; 
   char      data0 ;
   char      data1 ;
   char      data2 ;
   char      data3 ;
} notificationEnvelope ;
enum {
   FIFO_SUCCESS = 0,
   OVERRUN_OCCURRED
} ;
/*
 * Fifo Class
 */
class Fifo {
   public:
Fifo() {
   currentReadIndex = nextWriteIndex = 0 ;
   overrunOccurred = false ;
}
~Fifo() {}
int PushNotification( Notification theNotification, Component sender,
                 Component destination, char data0, char data1,
                 char data2, char data3 ) {
int rc = FIFO_SUCCESS ; 
if ( ( ( nextWriteIndex == NUMBER_OF_FIFO_BUFFER_SLOTS - 1 )
    && ( currentReadIndex == 0 ) )
  || ( nextWriteIndex + 1 == currentReadIndex ) ) {
   overrunOccurred = true ;
   rc = OVERRUN_OCCURRED ;
}
else {
   buf[ nextWriteIndex ].theNotification  = theNotification ;
   buf[ nextWriteIndex ].source      = sender ;
   buf[ nextWriteIndex ].destination = destination ;
   buf[ nextWriteIndex ].data0       = data0 ;
   buf[ nextWriteIndex ].data1       = data1 ;
   buf[ nextWriteIndex ].data2       = data2 ;
   buf[ nextWriteIndex ].data3       = data3 ;
   if ( ++nextWriteIndex == NUMBER_OF_FIFO_BUFFER_SLOTS ) {
      nextWriteIndex = 0 ;
   }
}
   return rc ;
}
int PopNotification( Notification &returnedNotification, Component &returnedSender,
                Component &returnedDestination, char &data0,
                char &data1, char &data2, char &data3 ) {
int rc = FIFO_SUCCESS ; 
if ( overrunOccurred ) {
   rc = OVERRUN_OCCURRED ;
} 
else {
   returnedNotification = buf[ currentReadIndex ].theNotification ;
   returnedSender       = buf[ currentReadIndex ].source ;
   returnedDestination  = buf[ currentReadIndex ].destination ;
   data0                = buf[ currentReadIndex ].data0 ;
   data1                = buf[ currentReadIndex ].data1 ;
   data2                = buf[ currentReadIndex ].data2 ;
   data3                = buf[ currentReadIndex ].data3 ;
   if ( currentReadIndex == NUMBER_OF_FIFO_BUFFER_SLOTS - 1 ) {
      currentReadIndex = 0 ;
   } else {
      currentReadIndex++ ;
   }
}
   return rc ;
}
bool IsEmpty( void ) {
   return overrunOccurred ? false : nextWriteIndex == currentReadIndex ;
}
Component IsFor( void ) {
   return buf[ currentReadIndex ].destination ;
}
   private:
unsigned int currentReadIndex ;
unsigned int nextWriteIndex ;
bool overrunOccurred ;
notificationEnvelope buf[ NUMBER_OF_FIFO_BUFFER_SLOTS ] ;
} ;
